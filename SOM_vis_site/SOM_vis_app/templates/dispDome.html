{%extends 'base.html'%}
{%block content%} 

<div >
    <h1> Geo Dome </h1>
    <form method="POST"  >
    {% csrf_token %}
        <select name="geoDome_list">

            {% for i in geoDome_list %}
                <option value="{{ i.id }}">{{ i.name }}</option>
            {% endfor %}
            
            {% if geoDome_list.count < 1%}
                <option>none</option>
            {% endif %}   

        </select>
        {%if geoDome_list.count > 0%}
            <input type="submit" name="action" value="ViewDetails"  />
        {%endif%}
    </form>
 
</div>


    <p id="test"> test </p>


<div id = dome_display>
     <script>

    
    // 0 = radius, 1 = azimuthAngle = lng,  2 = polarAngle = lat  all agles in radian 
    //https://stackoverflow.com/questions/5674149/3d-coordinates-on-a-sphere-to-latitude-and-longitude
    function sphericalCordConvert(x,y,z){
        var spherCodord = [];

        radius  =  Math.sqrt((x*x) + (y*y) + (z*z));
        
        lng = Math.atan2(y,x);
        
        lat = Math.atan2(z,Math.sqrt(x*x+y*y));
        

        spherCodord.push(radius);
        spherCodord.push(lng);
        spherCodord.push(lat);
        
        return spherCodord
    }

    

    //Wagnerâ€™s transformation of this projection use a bounding
    function wagnerTransform(boundParrallel,p,long, lat){
        let k = Math.sqrt(2*p* Math.sin(boundParrallel/2)/math.pi);
        let m = Math.sin(boundParrallel);

        //The result is between -pi/2 and pi/2.
        let theta = Math.asin(m * Math.sin(lat));
        let wagnerX = ((k/Math.sqrt(m)) * (   (long  * Math.cos(theta))/(Math.cos(theta/2))  )   );

        let wagnerY = (2/(k * Math.sqrt(m))) * Math.sin(theta/2);

        var wagnerCoOrd = [wagnerX, wagnerY];
;
        return wagnerCoOrd;
    }
    




        //create svg
        var width = 700 ;
        var height = 700 ;
        var dome_svg = d3.select("#dome_display").append("svg")
            .attr("viewBox", "-350 -350 700 700")
            .attr("width", width)
            .attr("height", height);

        var proj_svg = d3.select("#dome_display").append("svg")
                .attr("viewBox", "-350 -350 700 700")
                .attr("width", width)
                .attr("height", height);    

        // projection function
        function proj(x, y, z, svg) {
            if (z != null) {
                svg.append("circle")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("cz", z)
                    .attr("r", 3);
                    
            } else {
                svg.append("circle")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", 3)
            }
        }
        const dome_vertices = [];

        //init start vals 
        var startX = null;
        var startY = null;

        //returns the new cords of point after rotation 
        function rotationMatrix(theta, coord, pVect){          
            var x = math.subset(pVect, math.index(0));
            var y = math.subset(pVect, math.index(1));
            var z = math.subset(pVect, math.index(2));

            var sum = Math.sqrt(x ** 2 + y ** 2 + z ** 2);
            
            x = math.subset(pVect, math.index(0)) / sum ;
            y = math.subset(pVect, math.index(1)) / sum;
            z = math.subset(pVect, math.index(2)) / sum;


            //https://stackoverflow.com/questions/6721544/circular-rotation-around-an-arbitrary-axis
            var r = math.matrix([
                [
                    Math.cos(theta) + Math.pow(x, 2) * (1 - Math.cos(theta)),
                    x * y * (1 - Math.cos(theta)) - z * Math.sin(theta),
                    x * z * (1 - Math.cos(theta)) + y * Math.sin(theta)

                ],[
                    y * x * (1 - Math.cos(theta)) + z * Math.sin(theta),
                    Math.cos(theta) + Math.pow(y, 2) * (1 - Math.cos(theta)),
                    y * z * (1 - Math.cos(theta)) - x * Math.sin(theta)


                ],[
                    z * x * (1 - Math.cos(theta)) - y * Math.sin(theta),
                    z * y * (1 - Math.cos(theta)) + x * Math.sin(theta),
                    Math.cos(theta) + Math.pow(z, 2) * (1 - Math.cos(theta))
                ]
            ]);

           var res =  math.multiply(r, coord);
           return res;
        }
        
        document.getElementById("dome_display").onmousedown = function (e) {
            //set start to  click pos 
            startX = e.clientX;
            startY = e.clientY;
        };

        document.getElementById("dome_display").onmouseup = function (e) {
            startX = null;
            startY = null;
        };

        document.getElementById("dome_display").onmousemove = function (e) {
            if (startX == null) {
                return;
            }
            if (startY == null) {
                return;
            }

            //distance vextor
          var dx = e.clientX - startX ;
          var dy = e.clientY - startY;
  

            var vector = math.matrix([dx,dy,0]);


            //vector len
            var dist = parseFloat(Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2)));
            
            //angle 
            var axis  = math.matrix([0,0,-1]);
            var posVect = (math.cross(vector,axis));
            var unitV = math.divide(posVect, dist);
           
            
            //between 0 and 2pi
            var theta = Math.min(Math.max(parseFloat(   dist/300  ), 0), 2 * Math.PI);

            var newProj = [];
            //update all circles  in sphere 
            dome_svg.selectAll("circle").datum(function () {
                var currentCord = math.matrix([[this.getAttribute('cx')] , [this.getAttribute('cy')], [this.getAttribute('cz')]]);
                               
                var newCoords = rotationMatrix(theta, currentCord, unitV);              

                var x = math.subset(newCoords, math.index(0,0));
                var y = math.subset(newCoords, math.index(1,0));
                var z = math.subset(newCoords, math.index(2,0));        
            
                var tmp2 = this.getAttribute('cx') ** 2 + this.getAttribute('cy') ** 2 + this.getAttribute('cz') ** 2;
                var temp =  x ** 2 + y ** 2 + z ** 2;

                this.setAttribute('cx', x);
                this.setAttribute('cy', y);
                this.setAttribute('cz', z);
                
                var spherCodord = sphericalCordConvert(x, y, z);
                // bounding parallel = 61.9 and an equator (convert 61.9 = 1.080359 to radian) / central meridian ratio p = 2.03  
                var newProjCoOrd = wagnerTransform(1.080359, 2.03, spherCodord[1], spherCodord[2]);
                
                newProj.push(newProjCoOrd);
            
            });
            
            //update all circles in proj
            var i = 0;
            proj_svg.selectAll("circle").datum(function () {
                
                var newCoords = newProj[i];
               
                var x = newProj[i][0];
                var y = newProj[i][1];


                this.setAttribute('cx', x * 100);
                this.setAttribute('cy', y * 100) ;

                i ++;
            });
            
            // projList = create2dProj(Ord_list) 
            startY = e.clientY;
            startX = e.clientX;
        };

        var sumX = 0;
        var sumY = 0;
        var sumZ = 0;

    </script>


    
<div>

    {% for i in Ord_list %}
    
    <script> 
  
        var x = parseFloat("{{i.x}}" * 100);
        var y = parseFloat("{{i.y}}" * 100);
        var z = parseFloat("{{i.z}}" * 100);

     
        proj(x, y, z, dome_svg);
        dome_vertices.push(x, y, z);

        
    </script>

    {% endfor %}



</div>

<div>
    {% for i in Proj_list %}

    <script>
        var x = parseFloat("{{i.x}}" * 100);
        var y = parseFloat("{{i.y}}" * 100);
        proj(x, y, z, proj_svg);
    </script>

    {% endfor %}

</div>
    
</div>
{% endblock %}

