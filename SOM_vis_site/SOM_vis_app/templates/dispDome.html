{%extends 'base.html'%}
{%block content%} 

<div >
    <h1> Geo Dome </h1>
    <form method="POST"  >
    {% csrf_token %}
        <select name="geoDome_list">

            {% for i in geoDome_list %}
                <option value="{{ i.id }}">{{ i.name }}</option>
            {% endfor %}
            
            {% if geoDome_list.count < 1%}
                <option>none</option>
            {% endif %}   

        </select>
        {%if geoDome_list.count > 0%}
            <input type="submit" name="action" value="ViewDetails"  />
        {%endif%}
    </form>
 
</div>


    <p id="test"> test </p>


<div id = dome_display>
     <script>
        //create svg
        var width = 700 ;
        var height = 700 ;
        var dome_svg = d3.select("#dome_display").append("svg")
            .attr("viewBox", "-350 -350 700 700")
            .attr("width", width)
            .attr("height", height);

        var proj_svg = d3.select("#dome_display").append("svg")
                .attr("viewBox", "-350 -350 700 700")
                .attr("width", width)
                .attr("height", height);    

        // projection function
        function proj(x, y, z, svg) {
            if (z != null) {
                svg.append("circle")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("cz", z)
                    .attr("r", 3);
            } else {
                svg.append("circle")
                    .attr("cx", x)
                    .attr("cy", y)
                    .attr("r", 3)
            }
        }
        const dome_vertices = [];

        //init start vals 
        var startX = null;
        var startY = null;

        //returns the new cords of point after rotation 
        function rotationMatrix(theta, coord, pVect){          
            var x = math.subset(pVect, math.index(0));
            var y = math.subset(pVect, math.index(1));
            var z = math.subset(pVect, math.index(2));

            var sum = Math.sqrt(x ** 2 + y ** 2 + z ** 2);
            
            x = math.subset(pVect, math.index(0)) / sum ;
            y = math.subset(pVect, math.index(1)) / sum;
            z = math.subset(pVect, math.index(2)) / sum;
/*
            console.log("---------------------------------------------------------");
            console.log("t: "+theta);
            console.log("v: " +pVect);
            console.log("c: "+ coord);
            
            console.log("x: " + x );
             console.log("y: " + y);
              console.log("z: " + z);
        
*/

            //https://stackoverflow.com/questions/6721544/circular-rotation-around-an-arbitrary-axis
            var r = math.matrix([
                [
                    Math.cos(theta) + Math.pow(x, 2) * (1 - Math.cos(theta)),
                    x * y * (1 - Math.cos(theta)) - z * Math.sin(theta),
                    x * z * (1 - Math.cos(theta)) + y * Math.sin(theta)

                ],[
                    y * x * (1 - Math.cos(theta)) + z * Math.sin(theta),
                    Math.cos(theta) + Math.pow(y, 2) * (1 - Math.cos(theta)),
                    y * z * (1 - Math.cos(theta)) - x * Math.sin(theta)


                ],[
                    z * x * (1 - Math.cos(theta)) - y * Math.sin(theta),
                    z * y * (1 - Math.cos(theta)) + x * Math.sin(theta),
                    Math.cos(theta) + Math.pow(z, 2) * (1 - Math.cos(theta))
                ]
            ]);

           console.log("r " + r);
           var res =  math.multiply(r, coord);
           console.log("res : " + res);
           return res;
        }
        
        document.getElementById("dome_display").onmousedown = function (e) {
            //set start to  click pos 
            startX = e.clientX;
            startY = e.clientY;
        };

        document.getElementById("dome_display").onmouseup = function (e) {
            startX = null;
            startY = null;
        };

        document.getElementById("dome_display").onmousemove = function (e) {
            if (startX == null) {
                return;
            }
            if (startY == null) {
                return;
            }

            //distance vextor
          var dx = e.clientX - startX ;
          var dy = e.clientY - startY;
//            var dx = 0;
//            var dy = 1;            

            var vector = math.matrix([dx,dy,0]);
//            var vector = math.matrix([1, 0, 0]);

            //vector len
            var dist = parseFloat(Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2)));
            
            //angle 
            var axis  = math.matrix([0,0,-1]);
            var posVect = (math.cross(vector,axis));
            var unitV = math.divide(posVect, dist);
           

            //var newOrd = alpah * dist;
            //divide by rad
            
            //between 0 and 2pi
            var theta = Math.min(Math.max(parseFloat(   dist/200  ), 0), 2 * Math.PI);
            //var theta = Math.PI/10;

            console.log("d" +  dist);
            //update all circles  
            dome_svg.selectAll("circle").datum(function () {
                var currentCord = math.matrix([[this.getAttribute('cx')] , [this.getAttribute('cy')], [this.getAttribute('cz')]]);
                               
                var newCoords = rotationMatrix(theta, currentCord, unitV);              

                var x = math.subset(newCoords, math.index(0,0));
                var y = math.subset(newCoords, math.index(1,0));
                var z = math.subset(newCoords, math.index(2,0));        
                

/*
                console.log("=======================");
                console.log("before " + currentCord);
                console.log("after " + newCoords);
   */             
                
                var tmp2 = this.getAttribute('cx') ** 2 + this.getAttribute('cy') ** 2 + this.getAttribute('cz') ** 2;
               // console.log("sum before " + tmp2);
                var temp =  x ** 2 + y ** 2 + z ** 2;
              //  console.log("sum after " + temp );
               // console.log("=======================");
                
                
                this.setAttribute('cx', x);
                this.setAttribute('cy', y);
                this.setAttribute('cz', z);
             
            });
            startY = e.clientY;
            startX = e.clientX;
        };

        var sumX = 0;
        var sumY = 0;
        var sumZ = 0;



    </script>


    
<div>

    {% for i in Ord_list %}
    
    <script> 

        
        var x = parseFloat("{{i.x}}" * 100);
        var y = parseFloat("{{i.y}}" * 100);
        var z = parseFloat("{{i.z}}" * 100);

        sumX += x;
        sumY += y;
        sumZ += z; 
       
        proj(x, y, z, dome_svg);
        dome_vertices.push(x, y, z);

        
    </script>

    {% endfor %}

    <script>
        console.log("x" + sumX);
        console.log("y" + sumY);
        console.log("z" + sumZ);
    </script>

</div>

<div>
    {% for i in Proj_list %}

    <script>
        var x = parseFloat("{{i.x}}" * 100);
        var y = parseFloat("{{i.y}}" * 100);
        proj(x, y, z, proj_svg);
    </script>

    {% endfor %}

</div>
    
</div>
{% endblock %}

